# 트리의 부모 찾기

## 문제 :
트리의 루트를 1이라고 정했을 때, 각 노드의 부모를 구하는 프로그램을 작성

## 입력 :
1번쨰 줄에 노드의 개수, 2번째 줄부터 N-1개의 줄에 트리상에 연결된 두 노드가 주어짐

## 출력:
1번째 줄 부터 N-1개의 줄에 각 노드의 부모 노드 번호를 2번 노드부터 순서대로 출력


## 문제 풀이:

- 이중 리스트(그래프)를 이용해 구현합니다. 이때 리스트 내의 리스트 개수는 노드의 개수 + 1개 입니다 (0번 인데스를 사용하지 않기 위함)
- 그래프의 i 번째 리스트는 i번째 노드입니다. 
- i 번째 노드에는 연결된 모든 노드의 값이 들어갑니다. (부모, 자식 노드의 정보가 모두 들어감)
-  


## 코드 : 
```python
import sys
from collections import deque

# 입력 속도를 빠르게 하기 위해 sys.stdin.readline 사용
input = sys.stdin.readline

def solve():
    # 1. 노드의 개수 N 입력 받기
    N = int(input())

    # 2. 트리 구조를 저장할 그래프(리스트) 초기화
    # N+1개를 만드는 이유는 0번 인덱스를 비우고 1번부터 쓰기 위함
    graph = [[] for _ in range(N + 1)]

    # 3. 연결 정보 입력 받아서 그래프 만들기
    for _ in range(N - 1):
        a, b = map(int, input().split())
        graph[a].append(b)
        graph[b].append(a)
        # 서로 연결되어 있으므로 양쪽에 다 추가해줍니다.

    # 4. 부모 노드를 저장할 리스트 만들기
    # parent[i]는 i번 노드의 부모 번호를 저장함
    # 0으로 초기화해두고, 0이면 아직 방문 안 한 것으로 간주
    parent = [0] * (N + 1)

    # 5. BFS(너비 우선 탐색) 시작
    queue = deque([1]) # 루트 노드 1번부터 시작
    # (주의: 1번은 루트이므로 부모를 기록할 필요 없음)

    while queue:
        current = queue.popleft() # 현재 탐색 중인 노드

        # 현재 노드와 연결된 친구들을 모두 확인
        for child in graph[current]:
            # 연결된 친구의 부모가 아직 설정되지 않았다면 (방문 안 함)
            if parent[child] == 0:
                parent[child] = current # 현재 노드가 그 친구의 부모가 됨
                queue.append(child)     # 그 친구도 다음 탐색을 위해 줄(큐) 세움

    # 6. 정답 출력 (2번 노드부터 N번 노드까지 부모 출력)
    for i in range(2, N + 1):
        print(parent[i])

# 코드 실행
solve()

```

## 시뮬레이션:

### [start]
- **Queue** : `[1]`
- **Parent** : `[0,0,0,0,0...]`

### [루프 1회차]:
1. `popleft()` : 1이 나옴 (`current = 1`)
2. `graph[1]` 에 6,4 존재
3. **6번 확인**: `parent[6] == 0`
    - `parent[6] = 1` (6의 부모는 1)
    - `queue.append(6)`
4. **4번 확인**: `parent[4] == 0`
    - `parent[4] = 1` (4의 부모는 1)
    - `queue.append(4)`
5. 해당 과정을 반복하면 `parent` 에는 모두 부모 노드가 작성됩니다. 

