# 백준 1300 : 배열에서 K번째 수 찾기

## 1. 문제 개념 정리

### 배열 정의

- 크기: `N × N`
- 각 원소의 값:

```
A[i][j] = i × j   (1 ≤ i, j ≤ N)

```

이 배열을 1차원으로 펼쳐 정렬했을 때, **K번째로 작은 수**를 구하는 문제이다.

---

### 예시 (N = 3)

2차원 배열:

```
1  2  3
2  4  6
3  6  9

```

1차원으로 펼쳐 정렬:

```
[1, 2, 2, 3, 3, 4, 6, 6, 9]

```

K = 7일 때, 정답은 6이다.

---

## 2. 이진 탐색을 사용하는 이유

### 직접 구현의 한계

- 배열 크기는 최대 `N²`
- N이 최대일 경우, 메모리와 시간 모두 비효율적

### 핵심 관찰

> 어떤 값 X가 주어졌을 때,
> 
> 
> 배열에서 `X` 이하의 원소 개수는 빠르게 계산할 수 있다.
> 

따라서 이 문제는 **값의 범위에 대해 이진 탐색을 적용하는 문제**이다.

---

## 3. 핵심 아이디어

### 중간값 `mid`의 의미

```python
mid = (start + end) // 2

```

`mid`는 배열의 인덱스나 실제 K번째 값이 아니라,

**“이 값이 K번째 수가 될 수 있는가?”를 검증하기 위한 후보 값**이다.

---

### `mid` 이하의 수 개수 계산

i번째 행은 다음과 같다.

```
i, 2i, 3i, ..., Ni

```

조건:

```
i × j ≤ mid  →  j ≤ mid // i

```

열의 최대 개수는 N이므로:

```python
min(mid // i, N)

```

이를 모든 행에 대해 더하면 `mid` 이하의 전체 개수를 구할 수 있다.

```python
count = sum(min(mid // i, N) for i in range(1, N + 1))

```

---

## 4. 이진 탐색 조건

| count 결과 | 의미 | 처리 |
| --- | --- | --- |
| count < K | 값이 너무 작음 | start = mid + 1 |
| count ≥ K | 값이 충분히 큼 | end = mid - 1, 정답 후보 저장 |

즉, **count ≥ K를 처음 만족하는 최소 값이 정답**이다.

---

## 5. 전체 알고리즘 흐름

1. 탐색 범위 설정
    - start = 1
    - end = K
2. 중간값 계산
3. mid 이하의 수 개수 계산
4. count와 K 비교
5. 정답 출력

---

## 6. 파이썬 구현 코드

```python
N = int(input())
K = int(input())

start = 1
end = K
ans = 0

while start <= end:
    middle = (start + end) // 2

    cnt = 0
    for i in range(1, N + 1):
        cnt += min(middle // i, N)

    if cnt < K:
        start = middle + 1
    else:
        ans = middle
        end = middle - 1

print(ans)

```

---

## 7. 예시 흐름 (N = 3, K = 7)

| mid | count | 판단 |
| --- | --- | --- |
| 4 | 6 | 부족 → start 증가 |
| 6 | 8 | 충분 → 정답 후보 |
| 5 | 6 | 부족 |
| 최종 정답 | 6 |  |

---

## 8. 정리

- 배열을 실제로 생성하지 않는다
- 이진 탐색의 대상은 **인덱스가 아니라 값**
- `count ≥ K`를 만족하는 최소 값이 정답
- `end = K` 설정은 중요한 최적화 포인트
