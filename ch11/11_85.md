## 085 사전 찾기 (백준 1256)

### 1) 문제

알파벳 `a`가 N개, `z`가 M개로 이루어진 모든 문자열을 생각한다.
이 문자열들을 **사전순(lexicographical order)** 으로 정렬했을 때, **K번째 문자열**을 출력하라.

* 만들 수 있는 문자열의 개수가 K보다 작으면 `-1` 출력
* 입력: `N M K` (N, M ≤ 100, K ≤ 1,000,000,000)

---

### 2) 문제 설명 (예시 포함)

핵심은 “현재 자리에서 `a`를 선택했을 때 만들 수 있는 경우의 수”를 이용해, K번째 문자열을 한 글자씩 결정하는 것이다.

* 전체 길이 = `N + M`
* 어떤 문자열이든 결국 “N개 위치에 a를 놓는 방법”과 같으므로 총 경우의 수는
  [
  \binom{N+M}{M} = \binom{N+M}{N}
  ]

현재 남은 문자가 `a` N개, `z` M개일 때:

* 첫 글자를 `a`로 고정하면, 남은 (N-1개 a, M개 z)로 만들 수 있는 문자열 수는
  [
  T = \binom{(N-1)+M}{M}
  ]
* 만약 `T >= K`이면 K번째 문자열은 `a`로 시작한다.
* 아니라면 `z`로 시작하고, `a`로 시작하는 `T`개를 건너뛰므로 `K = K - T`로 갱신한다.

예시) `N=2, M=2, K=2`
사전순 나열: `aazz(1), azaz(2), azza(3), zaaz(4), zaza(5), zzaa(6)`
따라서 정답은 `azaz`.

추가 포인트:

* 조합 값은 매우 커질 수 있으므로, 실제로는 `K` 비교만 되면 된다.
* 그래서 조합 테이블을 만들 때 값이 `1e9`를 넘으면 `1e9+1`로 “상한 캡”을 씌워 저장한다.

---

### 3) 코드 + 주석 설명 (Python)

```python
import sys
input = sys.stdin.readline

N, M, K = map(int, input().split())

# 조합 테이블 C[n][r] (0 <= n <= 200)
# 값이 너무 커지는 것을 막기 위해 1e9+1로 캡을 씌운다.
CAP = 1_000_000_000 + 1
C = [[0] * 201 for _ in range(201)]

for n in range(201):
    C[n][0] = 1
    C[n][n] = 1
    for r in range(1, n):
        C[n][r] = C[n - 1][r - 1] + C[n - 1][r]
        if C[n][r] > CAP:
            C[n][r] = CAP

# 만들 수 있는 전체 문자열 수 = C[N+M][M]
if C[N + M][M] < K:
    print(-1)
    sys.exit()

# K번째 문자열을 한 글자씩 구성
ans = []
while N > 0 or M > 0:
    # a를 더 이상 못 쓰면 남은 건 전부 z
    if N == 0:
        ans.append('z')
        M -= 1
        continue

    # z를 더 이상 못 쓰면 남은 건 전부 a
    if M == 0:
        ans.append('a')
        N -= 1
        continue

    # 첫 글자를 a로 선택했을 때 만들 수 있는 문자열 수
    # 남은 문자는 (N-1개의 a, M개의 z) -> 총 길이 N+M-1 중 M개 위치에 z
    t = C[N + M - 1][M]

    if t >= K:
        # K번째가 a로 시작하는 그룹 안에 있음
        ans.append('a')
        N -= 1
    else:
        # a로 시작하는 t개를 건너뛰고 z로 시작
        ans.append('z')
        K -= t
        M -= 1

print(''.join(ans))
```

---
