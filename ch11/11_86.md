
## 086 선물 전달하기 (백준 1947)

### 1) 문제

N명이 있고 각자 선물을 1개씩 갖고 있다.
모든 사람이 선물을 **정확히 1개씩** 받되, **자기 선물은 자기가 받으면 안 된다.**
이 조건을 만족하는 “선물 전달 방법의 수”를 구하라.

* 입력: `N` (1 ≤ N ≤ 1,000,000)
* 출력: 경우의 수를 `1,000,000,000`으로 나눈 나머지

이 문제는 전형적인 **완전 순열(derangement)** 개수 문제다.

---

### 2) 문제 설명 (예시 포함)

완전 순열의 개수를 `D[n]`이라고 하자. (n명이 있을 때 자기 자신에게 가지 않는 순열의 수)

한 사람 A를 잡고, A가 선물을 줄 상대를 B로 선택한다고 하자.
A는 자기 자신을 제외한 `n-1`명 중 하나에게 줄 수 있으므로 경우를 나누면:

1. B가 A에게 선물을 주는 경우 (A ↔ B 서로 교환)

* A와 B는 확정됨
* 남은 `n-2`명은 완전 순열로 배치: `D[n-2]`

2. B가 A가 아닌 다른 사람에게 선물을 주는 경우

* A는 B에게 줬지만, B는 A에게 안 줌
* 이 상황을 적절히 묶어 세면 남은 배치가 `D[n-1]`로 정리된다.

따라서 점화식:
[
D[n] = (n-1)\times(D[n-1] + D[n-2])
]

초기값:

* `D[1] = 0` (1명은 무조건 자기 자신)
* `D[2] = 1` (서로 교환 1가지)

예시) N=5

* D3 = 2
* D4 = 9
* D5 = 44
  출력 예시가 44가 된다.

---

### 3) 코드 + 주석 설명 (Python)

```python
import sys
input = sys.stdin.readline

N = int(input().strip())
MOD = 1_000_000_000

# N이 최대 1,000,000이므로 O(N) DP로 해결
# D[n] = (n-1) * (D[n-1] + D[n-2]) mod MOD
if N == 1:
    print(0)
    sys.exit()
if N == 2:
    print(1)
    sys.exit()

d1 = 0  # D[1]
d2 = 1  # D[2]

for n in range(3, N + 1):
    d = (n - 1) * (d2 + d1) % MOD
    d1, d2 = d2, d

print(d2)
```
