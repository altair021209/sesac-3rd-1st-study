# 이항 계수 2

- 앞선 문제와 똑같이 이항 계수 $_nC_k$를 구하는 문제입니다.
- 하지만 **N이 최대 1,000**으로 커졌습니다. 
- 팩토리얼로 풀 경우 숫자가 너무 커져서 연산이 느려지거나 오버플로우가 발생할 수 있습니다. 또한, 결과값을 10,007로 나눈 나머지를 출력해야 하므로 나눗셈 연산이 복잡해집니다.
- 따라서 공식을 직접 계산하는 대신, **점화식(동적 계획법, DP)**을 사용하여 덧셈으로 문제를 해결해야 합니다.

# 과정

- **점화식 도출**: 
  $D[i][j]$ = $i$개 중 $j$개를 뽑는 경우의 수
  **$D[i][j] = D[i-1][j] + D[i-1][j-1]$** (즉, 5개 중 3개를 뽑는 경우 = '특정 숫자를 제외하고 4개 중 3개를 뽑는 것' + '특정 숫자를 포함하고 4개 중 2개를 뽑는 것')
  
- 2차원 리스트(DP 테이블) 초기화
- 이중 반복문을 돌며 점화식으로 값을 채움
- 계산할 때마다 10,007로 모듈러 연산을 수행하여 숫자가 커지는 것을 방지

# 코드

```python
import sys
input = sys.stdin.readline

# 1. 입력 받기
N, K = map(int, input().split())

# 2. DP 테이블 초기화 (N+1 x N+1 크기)
# D[i][j] : i개 중에서 j개를 뽑는 조합의 수
D = [[0 for _ in range(N + 1)] for _ in range(N + 1)]

# 3. 초기값 설정
for i in range(N + 1):
    D[i][1] = i      # i개 중 1개를 뽑는 경우는 i가지
    D[i][0] = 1      # i개 중 0개를 뽑는 경우는 1가지 (공집합)
    D[i][i] = 1      # i개 중 i개를 모두 뽑는 경우는 1가지

# 4. 점화식으로 테이블 채우기
# i는 총 개수, j는 선택 개수
for i in range(2, N + 1):
    for j in range(1, i):
        # 점화식: D[i][j] = D[i-1][j] + D[i-1][j-1]
        D[i][j] = (D[i-1][j] + D[i-1][j-1]) % 10007

print(D[N][K])