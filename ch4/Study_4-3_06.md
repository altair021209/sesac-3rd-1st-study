# 백준 2018 : 연속된 자연수의 합 구하기

## 1. 문제 개념 정리

### 문제 요약

자연수 `N`이 주어질 때, `N`을 **연속된 자연수들의 합**으로 표현할 수 있는 경우의 수를 구하는 문제이다.

### 예시

```
N = 15

1 + 2 + 3 + 4 + 5 = 15
4 + 5 + 6 = 15
7 + 8 = 15
15 = 15

```

위와 같이 총 4가지 경우가 존재한다.

이 문제의 핵심은 **연속된 자연수 구간 [start, end]의 합이 N이 되는 경우의 수를 효율적으로 탐색하는 것**이다.

---

## 2. 투 포인터(Two Pointer) 핵심 개념

이 문제는 연속된 구간의 합을 다루므로, 투 포인터 기법을 사용하면 효율적으로 해결할 수 있다.

### 포인터 및 변수 정의

| 변수 | 의미 |
| --- | --- |
| `start_index` | 연속 구간의 시작 값 |
| `end_index` | 연속 구간의 끝 값 |
| `sum` | start부터 end까지의 누적 합 |
| `count` | 조건을 만족하는 경우의 수 |

### 초기 상태

```
start = 1
end = 1
sum = 1

```

---

## 3. 포인터 이동 규칙

투 포인터 알고리즘의 핵심은 현재 구간 합 `sum`과 목표값 `N`을 비교하며 포인터를 이동시키는 규칙에 있다.

### 경우 1: `sum == N`

- 하나의 정답을 찾은 상태
- 경우의 수를 증가시킨다
- 다음 구간을 탐색하기 위해 `end` 포인터를 증가시킨다

### 경우 2: `sum > N`

- 현재 구간 합이 너무 큰 경우
- 시작 지점을 오른쪽으로 이동시켜 구간을 줄인다

```python
sum -= start
start += 1

```

### 경우 3: `sum < N`

- 현재 구간 합이 부족한 경우
- 끝 지점을 오른쪽으로 이동시켜 구간을 늘린다

```python
end += 1
sum += end

```

이 과정을 `end`가 `N`에 도달할 때까지 반복한다.

---

## 4. 알고리즘 요약

> 구간 합이 작으면 확장하고, 크면 축소하며, 같으면 경우의 수를 증가시킨다.
> 

---

## 5. 파이썬 구현 코드

```python
n = int(input())

# 자기 자신(n = n)도 하나의 경우이므로 초기값은 1
count = 1

# 투 포인터 초기화
start_index = 1
end_index = 1
sum = 1

# end가 n이 될 때까지 반복
while end_index != n:

    # 합이 n과 같은 경우
    if sum == n:
        count += 1
        end_index += 1
        sum += end_index

    # 합이 n보다 큰 경우
    elif sum > n:
        sum -= start_index
        start_index += 1

    # 합이 n보다 작은 경우
    else:
        end_index += 1
        sum += end_index

print(count)

```

---

## 6. 예시 흐름 (N = 15)

| start | end | sum | 처리 |
| --- | --- | --- | --- |
| 1 | 1 | 1 | end 이동 |
| 1 | 5 | 15 | 경우의 수 증가 |
| 4 | 6 | 15 | 경우의 수 증가 |
| 7 | 8 | 15 | 경우의 수 증가 |
| 15 | 15 | 15 | 경우의 수 증가 |
